# 원시 값과 객체의 비교

자바스크립트의 데이터 타입은 크게 **원시 타입(Primitive Type)**과 **객체 타입(Object/Reference Type)**으로 나뉩니다. 이 둘을 구분하는 이유는 근본적인 동작 방식의 차이 때문입니다.

## 1. 원시 타입 vs 객체 타입의 차이점

| 구분            | 원시 타입                                | 객체 타입                                      |
| --------------- | ---------------------------------------- | ---------------------------------------------- |
| **변경 가능성** | **변경 불가능 (Immutable)**              | **변경 가능 (Mutable)**                        |
| **저장 값**     | 실제 값(Actual Value)이 저장됨           | 참조 값(Reference Value)이 저장됨              |
| **할당/전달**   | **값에 의한 전달**: 값이 복사되어 전달됨 | **참조에 의한 전달**: 주소값이 복사되어 전달됨 |

---

## 2. 원시 값의 특징: 문자열과 불변성

문자열은 원시 값이며 **불변성(Immutability)**을 가집니다.

- **유사 배열 객체:** 문자열은 인덱스로 접근 가능(`str[0]`)하고 `length` 프로퍼티를 가지며 `for`문 순회가 가능합니다.
- **읽기 전용:** 인덱스로 접근하여 값을 수정하려 해도 반영되지 않습니다. (에러는 발생하지 않음)

```javascript
let str = "won";
str[0] = "W"; // 무시됨
console.log(str); // 'won' (원본 변경 불가)
```

---

## 3. 객체의 특징과 V8 엔진 최적화

객체는 동적으로 프로퍼티를 추가/삭제할 수 있어 관리가 복잡하며 메모리 비용이 더 많이 듭니다.

### 히든 클래스 (Hidden Class)

V8 엔진은 동적 객체의 성능을 높이기 위해 **히든 클래스** 기법을 사용합니다.

- **고정된 레이아웃:** 객체 생성 시 내부적인 설계도(히든 클래스)를 만들어 구조를 고정합니다.
- **오프셋(Offset) 계산:** 프로퍼티의 메모리 위치를 미리 파악하여 딕셔너리 탐색 없이 즉시 접근합니다.
- **최적화 팁:** 객체를 생성할 때 프로퍼티 추가 순서를 동일하게 유지하면 히든 클래스를 공유하여 성능이 향상됩니다.

---

## 4. 객체의 변경 가능성 (Mutable Value)

객체는 변수에 저장된 참조 값을 통해 실제 메모리 공간에 접근하므로, **재할당 없이 객체를 직접 수정**할 수 있습니다.

### 얕은 복사 vs 깊은 복사

- **얕은 복사 (Shallow Copy):** 가장 바깥쪽 값만 복사. 중첩 객체는 참조(주소)를 공유합니다.
- `const copy = { ...original };`

- **깊은 복사 (Deep Copy):** 모든 수준의 중첩 객체까지 새로운 메모리에 복사.
- `const copy = structuredClone(original);`

---

## 5. 참조에 의한 전달의 부작용

객체를 공유하거나 함수 인수로 전달할 때 발생할 수 있는 주요 문제입니다.

1. **의도치 않은 데이터 오염:** 여러 변수가 같은 주소를 공유하므로, 한 곳에서의 수정이 다른 모든 곳에 영향을 줍니다.
2. **함수 내부의 부작용 (Side Effect):** 함수가 인수로 받은 객체를 수정하면 함수 외부의 원본 데이터가 변경되어 코드의 예측 가능성이 떨어집니다.
3. **복잡한 디버깅:** 데이터의 변경 시점과 주체를 추적하기가 매우 어려워집니다.

```javascript
function increaseScore(obj) {
  obj.score += 1; // 외부 객체에 영향을 주는 부작용 발생
}

let user = { score: 0 };
increaseScore(user);
console.log(user.score); // 1
```
